// Code generated by protoc-gen-go.
// source: model/example.proto
// DO NOT EDIT!

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	model/example.proto

It has these top-level messages:
	User
	Post
	PostContent
	Attachment
	File
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// User represents a registered user.
type User struct {
	// Id is a unique ID for this user.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name is the name of this user.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Password is the user's hashed password.
	Password []byte `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// LastLoginTime is the unix timestamp of the user's last login.
	LastLoginTime int64 `protobuf:"varint,4,opt,name=last_login_time,json=lastLoginTime" json:"last_login_time,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *User) GetLastLoginTime() int64 {
	if m != nil {
		return m.LastLoginTime
	}
	return 0
}

// Post is a post from a user.
type Post struct {
	// Id is the unique ID of this post.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// UserId is the ID of the user who posted this post.
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Content is the content of the post.
	Content *PostContent `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`
}

func (m *Post) Reset()                    { *m = Post{} }
func (m *Post) String() string            { return proto.CompactTextString(m) }
func (*Post) ProtoMessage()               {}
func (*Post) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Post) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Post) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Post) GetContent() *PostContent {
	if m != nil {
		return m.Content
	}
	return nil
}

// PostContent is the content of a post.
type PostContent struct {
	// Text is the text of the post.
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	// Attachments are optional attachment to the post.
	Attachments []*Attachment `protobuf:"bytes,2,rep,name=attachments" json:"attachments,omitempty"`
}

func (m *PostContent) Reset()                    { *m = PostContent{} }
func (m *PostContent) String() string            { return proto.CompactTextString(m) }
func (*PostContent) ProtoMessage()               {}
func (*PostContent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PostContent) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *PostContent) GetAttachments() []*Attachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

// Attachment is a non-text attachment to a post.
type Attachment struct {
	// Types that are valid to be assigned to Attachment:
	//	*Attachment_Url
	//	*Attachment_File
	Attachment isAttachment_Attachment `protobuf_oneof:"attachment"`
}

func (m *Attachment) Reset()                    { *m = Attachment{} }
func (m *Attachment) String() string            { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()               {}
func (*Attachment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isAttachment_Attachment interface {
	isAttachment_Attachment()
}

type Attachment_Url struct {
	Url string `protobuf:"bytes,1,opt,name=url,oneof"`
}
type Attachment_File struct {
	File *File `protobuf:"bytes,2,opt,name=file,oneof"`
}

func (*Attachment_Url) isAttachment_Attachment()  {}
func (*Attachment_File) isAttachment_Attachment() {}

func (m *Attachment) GetAttachment() isAttachment_Attachment {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *Attachment) GetUrl() string {
	if x, ok := m.GetAttachment().(*Attachment_Url); ok {
		return x.Url
	}
	return ""
}

func (m *Attachment) GetFile() *File {
	if x, ok := m.GetAttachment().(*Attachment_File); ok {
		return x.File
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Attachment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Attachment_OneofMarshaler, _Attachment_OneofUnmarshaler, _Attachment_OneofSizer, []interface{}{
		(*Attachment_Url)(nil),
		(*Attachment_File)(nil),
	}
}

func _Attachment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Attachment)
	// attachment
	switch x := m.Attachment.(type) {
	case *Attachment_Url:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Url)
	case *Attachment_File:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.File); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Attachment.Attachment has unexpected type %T", x)
	}
	return nil
}

func _Attachment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Attachment)
	switch tag {
	case 1: // attachment.url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Attachment = &Attachment_Url{x}
		return true, err
	case 2: // attachment.file
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(File)
		err := b.DecodeMessage(msg)
		m.Attachment = &Attachment_File{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Attachment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Attachment)
	// attachment
	switch x := m.Attachment.(type) {
	case *Attachment_Url:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Url)))
		n += len(x.Url)
	case *Attachment_File:
		s := proto.Size(x.File)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// File is a blob.
type File struct {
	// MimeType is the MIME type of the file.
	MimeType string `protobuf:"bytes,1,opt,name=mime_type,json=mimeType" json:"mime_type,omitempty"`
	// Content is the contents of the file.
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *File) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *File) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func init() {
	proto.RegisterType((*User)(nil), "model.User")
	proto.RegisterType((*Post)(nil), "model.Post")
	proto.RegisterType((*PostContent)(nil), "model.PostContent")
	proto.RegisterType((*Attachment)(nil), "model.Attachment")
	proto.RegisterType((*File)(nil), "model.File")
}

func init() { proto.RegisterFile("model/example.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 312 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x51, 0x4d, 0x4b, 0xc3, 0x40,
	0x10, 0x6d, 0x3e, 0xec, 0xc7, 0xa4, 0x2a, 0x8e, 0x07, 0x83, 0x5e, 0x62, 0x0e, 0x92, 0x83, 0x54,
	0x68, 0xcf, 0x1e, 0x54, 0x90, 0x0a, 0x1e, 0x74, 0xa9, 0xde, 0x24, 0xc4, 0x66, 0xd4, 0x85, 0xdd,
	0x6c, 0xc8, 0x6e, 0xb1, 0xfd, 0xf7, 0xb2, 0xdb, 0xf4, 0x03, 0xbc, 0xcd, 0x7b, 0x6f, 0x78, 0x6f,
	0x3e, 0xe0, 0x54, 0xaa, 0x92, 0xc4, 0x0d, 0x2d, 0x0b, 0x59, 0x0b, 0x1a, 0xd5, 0x8d, 0x32, 0x0a,
	0x0f, 0x1c, 0x99, 0x56, 0x10, 0xbe, 0x69, 0x6a, 0xf0, 0x08, 0x7c, 0x5e, 0xc6, 0x5e, 0xe2, 0x65,
	0x03, 0xe6, 0xf3, 0x12, 0x11, 0xc2, 0xaa, 0x90, 0x14, 0xfb, 0x8e, 0x71, 0x35, 0x9e, 0x43, 0xbf,
	0x2e, 0xb4, 0xfe, 0x55, 0x4d, 0x19, 0x07, 0x89, 0x97, 0x0d, 0xd9, 0x16, 0xe3, 0x15, 0x1c, 0x8b,
	0x42, 0x9b, 0x5c, 0xa8, 0x6f, 0x5e, 0xe5, 0x86, 0x4b, 0x8a, 0xc3, 0xc4, 0xcb, 0x02, 0x76, 0x68,
	0xe9, 0x67, 0xcb, 0xce, 0xb8, 0xa4, 0xf4, 0x03, 0xc2, 0x17, 0xa5, 0xcd, 0xbf, 0xbc, 0x33, 0xe8,
	0x2d, 0x34, 0x35, 0x39, 0x2f, 0xdb, 0xc8, 0xae, 0x85, 0x4f, 0x25, 0x5e, 0x43, 0x6f, 0xae, 0x2a,
	0x43, 0x95, 0x71, 0x99, 0xd1, 0x18, 0x47, 0x6e, 0xf2, 0x91, 0xb5, 0x79, 0x58, 0x2b, 0x6c, 0xd3,
	0x92, 0xbe, 0x43, 0xb4, 0xc7, 0xdb, 0x2d, 0x0c, 0x2d, 0x4d, 0x9b, 0xe3, 0x6a, 0x9c, 0x40, 0x54,
	0x18, 0x53, 0xcc, 0x7f, 0x24, 0x55, 0x46, 0xc7, 0x7e, 0x12, 0x64, 0xd1, 0xf8, 0xa4, 0x35, 0xbd,
	0xdb, 0x2a, 0x6c, 0xbf, 0x2b, 0x7d, 0x05, 0xd8, 0x49, 0x88, 0x10, 0x2c, 0x1a, 0xb1, 0x76, 0x9d,
	0x76, 0x98, 0x05, 0x78, 0x09, 0xe1, 0x17, 0x17, 0xeb, 0x83, 0x45, 0xe3, 0xa8, 0xf5, 0x7b, 0xe4,
	0x82, 0xa6, 0x1d, 0xe6, 0xa4, 0xfb, 0x21, 0xc0, 0xce, 0x33, 0xbd, 0x85, 0xd0, 0xaa, 0x78, 0x01,
	0x03, 0xc9, 0x25, 0xe5, 0x66, 0x55, 0x53, 0x3b, 0x68, 0xdf, 0x12, 0xb3, 0x55, 0x4d, 0x18, 0xef,
	0xb6, 0xf7, 0xdd, 0xc5, 0x37, 0xf0, 0xb3, 0xeb, 0xde, 0x38, 0xf9, 0x0b, 0x00, 0x00, 0xff, 0xff,
	0x4d, 0xf1, 0x53, 0x42, 0xdd, 0x01, 0x00, 0x00,
}
